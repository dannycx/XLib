# Face

## 1. 进程间通信方式
#### 匿名共享内存
1. 速度快
2. 需同步处理：多进程（线程）读写操作，需暂停所有读，仅保留一个写完，所有写完，再读。
#### socket（管道通信）
1. 速度慢：须经过两次拷贝，导致通信慢。
2. 可传递大数据。
3. 可用来做C/S模式（一个server端可同时与多个client端）通信。
#### signal（信号机制）
1. 限制：一次通信只能传递一个int整数。
#### 信号量
#### Binder通信
1. 支持C/S模式。
2. 速度仅次于匿名共享内存，仅拷贝一次数据。
3. 进程启动时需创建一定大小的共享内存。
4. 至少需启动一个binder线程为通信做准备（通信量大时需更多binder线程）。
5. 使用共享内存机制，也需解决同步问题。
6. 应用于：数据量大，通信频繁场景。

## 2. 数据结构
#### 数组
1. 按序排列，查找速度快（二分查找）。
2. 增删效率低。
#### HashMap
1. 查询快，增删查效率高。
2. 扩容复杂。
3. 结合数组和链表两种结构，当存在大量的key值的hash值一样时，查找效率会降低。
4. 数据量大时会存在浪费内存的场景。
5. 大数据量时不建议使用：内存浪费 + 查找效率低下。

## 3. Android属性服务
1. 采用域名格式设计key，即可做到权限控制，又可根据前缀区分不同类别属性（control，sys）。
2. 利用链表 + 二叉树存储key value属性，节省内存，加快查找效率，增删也利用链表的优势。
3. 分组：大块共享内存按key值关联性划分为小共享内存空间，无关性的放在default共享内存中。
4. init进程启动时启动属性服务系统，提前把磁盘中存储属性读取至内存中。
5. init处理：control、sys，只读：ro，
#### 查找过程
* key -> 找对应ContextNode -> 找对应prop_area -> 找prop_bt -> 找对应key的prop_info -> value

